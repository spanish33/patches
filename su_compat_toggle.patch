From 094b39bb43d12e6ce3a3dc2bc1e911a31345524a Mon Sep 17 00:00:00 2001
From: backslashxx <118538522+backslashxx@users.noreply.github.com>
Date: Sat, 8 Mar 2025 09:55:58 -0500
Subject: [PATCH 2/4] KernelSU: Support sucompat toggle for integrated hooks

tiann/KernelSU#2506

This probably isn't useful, and definitely isn't necessary for manually
integrated hooks but it is pretty neat. More importantly it maintains
feature parity with the upstream KPROBE implementation by providing an
avenue to effectively disable all KernelSU hooks, if for whatever you
wanted to do that.

Signed-off-by: backslashxx <118538522+backslashxx@users.noreply.github.com>
Signed-off-by: Adam W. Willis <return.of.octobot@gmail.com>
---
 kernel/sucompat.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/kernel/sucompat.c b/kernel/sucompat.c
index 5aa29725..7aeb91c9 100644
--- a/kernel/sucompat.c
+++ b/kernel/sucompat.c
@@ -22,6 +22,8 @@
 
 extern void ksu_escape_to_root();
 
+static bool ksu_sucompat_integrated __read_mostly = true;
+
 static void __user *userspace_stack_buffer(const void *d, size_t len)
 {
 	/* To avoid having to mmap a page in userspace, just write below the stack
@@ -50,6 +52,10 @@ int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
 {
 	const char su[] = SU_PATH;
 
+	if (!ksu_sucompat_integrated) {
+ 		return 0;
+ 	}
+
 	if (!ksu_is_allow_uid(current_uid().val)) {
 		return 0;
 	}
@@ -71,6 +77,10 @@ int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags)
 	// const char sh[] = SH_PATH;
 	const char su[] = SU_PATH;
 
+	if (!ksu_sucompat_integrated) {
+ 		return 0;
+ 	}
+
 	if (!ksu_is_allow_uid(current_uid().val)) {
 		return 0;
 	}
@@ -115,6 +125,10 @@ int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
 	const char sh[] = KSUD_PATH;
 	const char su[] = SU_PATH;
 
+	if (!ksu_sucompat_integrated) {
+ 		return 0;
+ 	}
+
 	if (unlikely(!filename_ptr))
 		return 0;
 
@@ -144,6 +158,10 @@ int ksu_handle_execve_sucompat(int *fd, const char __user **filename_user,
 	const char su[] = SU_PATH;
 	char path[sizeof(su) + 1];
 
+	if (!ksu_sucompat_integrated){
+ 		return 0;
+ 	}
+
 	if (unlikely(!filename_user))
 		return 0;
 
@@ -166,6 +184,10 @@ int ksu_handle_execve_sucompat(int *fd, const char __user **filename_user,
 
 int ksu_handle_devpts(struct inode *inode)
 {
+	if (!ksu_sucompat_integrated){
+ 		return 0;
+ 	}
+
 	if (!current->mm) {
 		return 0;
 	}
@@ -273,6 +295,9 @@ void ksu_sucompat_init()
 	su_kps[1] = init_kprobe(SYS_FACCESSAT_SYMBOL, faccessat_handler_pre);
 	su_kps[2] = init_kprobe(SYS_NEWFSTATAT_SYMBOL, newfstatat_handler_pre);
 	su_kps[3] = init_kprobe("pts_unix98_lookup", pts_unix98_lookup_pre);
+#else
+	ksu_sucompat_integrated = true;
+	pr_info("ksu_sucompat_init: hooks enabled: execve/execveat_su, faccessat, stat, devpts\n");
 #endif
 }
 
@@ -282,5 +307,8 @@ void ksu_sucompat_exit()
 	for (int i = 0; i < ARRAY_SIZE(su_kps); i++) {
 		destroy_kprobe(&su_kps[i]);
 	}
+#else
+	ksu_sucompat_integrated = false;
+	pr_info("ksu_sucompat_exit: hooks disabled: execve/execveat_su, faccessat, stat, devpts\n");
 #endif
 }
-- 
2.43.0

